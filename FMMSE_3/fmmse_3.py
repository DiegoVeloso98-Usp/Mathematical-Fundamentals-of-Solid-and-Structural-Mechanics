# -*- coding: utf-8 -*-
"""FMMSE_3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Wrke8qJPGzvo_CO7TJdsjvvEt8PExj5j

Principle of Virtual Work
 - Euler-Bernoulli Beam
"""



import sympy as sp
import numpy as np
import matplotlib.pyplot as plt
import numpy as np
import matplotlib as mpl

# Define symbols
x   =   sp.Symbol('x')
E   =   sp.Symbol('E')  # Young's Modulus
I   =   sp.Symbol('I')  # Area Moment of Inertia
v   =   sp.Function('v')(x)  # Virtual displacement field
w   =   sp.Function('\delta v')(x)  # Actual displacement field
q   =   sp.Symbol('q')  # Distributed load
P0  =   sp.Symbol('P_0')  # Concentraded load
PL  =   sp.Symbol('P_L')  # Concentraded load
M0  =   sp.Symbol('M_0')  # Concentraded moment
ML  =   sp.Symbol('M_L')  # Concentraded moment
L = sp.Symbol('L')
k = sp.Symbol('k')

# Define the principle of virtual work in integral form
# The integral represents the virtual work done by internal and external forces.
# Integral( E * I * w'' * v'' ) dx - Integral( q * v ) dx = 0
dvdx    = sp.Derivative(v, x)
dv2dx2  = sp.Derivative(dvdx, x)
dwdx    = sp.Derivative(w, x)
dw2dx2  = sp.Derivative(dwdx, x)


# Internal virtual work integral (due to bending moment)
W_int = sp.Integral(-E*I*dv2dx2*dw2dx2, (x, 0, L))

# External virtual work integral
# (due to distributed and concentraded forces and concentraded moments)
W_ext_q = sp.Integral(q * w, (x, 0, L))
W_ext_P = P0*w.subs(x,0) + PL*w.subs(x,L)
W_ext_M = M0*dwdx.subs(x,0) + ML*dwdx.subs(x,L)
W_ext_k = -k*v.subs(x,0)*w.subs(x,0) - k*v.subs(x,L)*w.subs(x,L)
W_ext = W_ext_q + W_ext_P + W_ext_M + W_ext_k


# The principle of virtual work statement:
# internal_virtual_work - external_virtual_work = 0
PVW = sp.Eq(W_ext, W_int)

# print("Internal Virtual Work Integral:")
print(sp.latex(W_int))

# print("\nExternal Virtual Work Integral:")
print(sp.latex(W_ext))

# print("\nPrinciple of Virtual Work Statement (Integral Form):")
display(PVW)

def ApproximationFunctions(order):
    # Create alpha and delta_alpha symbols dynamically
    alphas = sp.symbols(f'alpha0:{order+1}')
    delta_alphas = [sp.Symbol(fr'\delta \alpha_{i}') for i in range(order + 1)]

    # Display the symbols
    display(*alphas)
    display(*delta_alphas)

    # Construct the polynomials v_poly and w_poly
    v_poly = sum(alphas[i] * x**i for i in range(order + 1))
    w_poly = sum(delta_alphas[i] * x**i for i in range(order + 1))

    # Display the polynomials
    display(v_poly)
    display(w_poly)

    # Optional: return the symbols and expressions if needed
    return alphas, delta_alphas, v_poly, w_poly

def apply_boundary_conditions(v_poly, alphas, L, n_elim=4):
    """
    Enforce boundary conditions:
        v(0) = 0
        v(L) = 0
        v''(0) = 0
        v''(L) = 0
    and solve for the first `n_elim` alpha_i coefficients.

    Parameters:
        v_poly: symbolic polynomial expression for v(x)
        alphas: list of alpha symbols
        L: symbolic length variable
        n_elim: how many alpha_i to eliminate (default: 4)

    Returns:
        v_poly_bc: BC-enforced polynomial
        sol_BC: dictionary of substitutions applied
    """
    # Compute second derivative
    vpp = sp.diff(v_poly, x, 2)


    print("v(x)")
    print(sp.latex(v_poly))
    print("v(0)=")
    print(sp.latex(sp.Eq(v_poly.subs(x, 0), 0)))
    print("v(L)=")
    print(sp.latex(sp.Eq(v_poly.subs(x, L), 0)))

    print("v''=")
    print(sp.latex(vpp))
    print("v''(0)=")
    print(sp.latex(sp.Eq(vpp.subs(x, 0), 0)))
    print("v''(L)=")
    print(sp.latex(sp.Eq(vpp.subs(x, L), 0)))

    # Apply boundary conditions
    bc_eqs = [
        sp.Eq(v_poly.subs(x, 0), 0),
        sp.Eq(v_poly.subs(x, L), 0)
    ]

    # Determine which coefficients to eliminate
    unknowns_to_solve = alphas[:n_elim]

    # Solve
    sol_BC = sp.solve(bc_eqs, unknowns_to_solve, dict=True)[0]

    # Substitute into v_poly
    v_poly_bc = sp.expand(v_poly.subs(sol_BC))
    # v_poly_bc = sp.expand(v_poly.subs(sol_BC))

    return v_poly_bc

def extract_basis_functions(v_poly_bc, alphas):
    """
    Extract basis functions φ_j(x) from BC-enforced polynomials.
    Parameters:
        v_poly_bc: BC-enforced displacement polynomial
        alphas: full list of alpha symbols
        sol_BC: dict of alpha substitutions from BC enforcement

    Returns:
        phi_basis: dict mapping alpha_j → φ_j(x)
    """
    # Extract φᵢ(x) = coefficient of αᵢ in v_poly_bc
    phi_list = [ sp.simplify(v_poly_bc.coeff(alpha_i, 1)) for alpha_i in alphas ]

    # You can inspect them if you like:
    for i,phi in enumerate(phi_list):
        print(f"\phi{i}(x) =", sp.latex(phi))

    return phi_list

def ComputeSecondDerivatives(phi_basis):
  d2_phi_dx2 = [ sp.diff(phi, x, 2) for phi in phi_basis ]
  print("d2_phi_dx2 =")
  display(d2_phi_dx2)
  return d2_phi_dx2

def AssembleAndSolve(phi_basis, d2_phi_dx2):
  # (D) Assemble the 4×4 stiffness matrix K in a nested loop
  n = len(d2_phi_dx2)  # = 4
  K = sp.zeros(n, n)

  for i in range(n):
      for j in range(n):
          K[i, j] = sp.integrate(E*I * d2_phi_dx2[j] * d2_phi_dx2[i], (x, 0, L))
          K[i, j] += k * phi_basis[i].subs(x, L) * phi_basis[j].subs(x, L)
          if i == j and K[i,j] == 0:
              K[i,j] = 1

  display(K)
  # (E) Display the result
  print("Stiffness matrix K_{ij}:")
  print(sp.latex(K))

  F = sp.zeros(n, 1)
  for i in range(n):
      F[i,0] = sp.simplify( sp.integrate(q * phi_basis[i], (x,0,L)) )

  display(F)
  print("Force vector")
  print(sp.latex(F))

  alpha_vec = sp.simplify(K.LUsolve(F))

  print("Solution")
  print(sp.latex(alpha_vec))
  return alpha_vec

def ReconstructSolution(alpha_vec,phi_basis):
  n = len(phi_basis)
  # 6) Reconstruct v(x) = Σ α_i φ_i(x)
  v_solution = sum(alpha_vec[i] * phi_basis[i] for i in range(n))
  print("Reconstructed v(x):")
  print(sp.latex(v_solution))
  return v_solution

def PlotSolution(v_solution, numeric_values, tol=1e-12):
    # 1) substitute numeric values into v(x)
    print("Test 1")
    v_num = v_solution.subs(numeric_values)
    # 2) build M(x) = -E*I*v''(x) symbolically then substitute
    print("Test 2")
    M_sym = -numeric_values[E] * numeric_values[I] * sp.diff(v_solution, x, 2)
    M_num = sp.simplify(M_sym.subs(numeric_values))

    print("Test 3")
    # 3) lambdify both
    v_fun = sp.lambdify(x, v_num, 'numpy')
    M_fun = sp.lambdify(x, M_num, 'numpy')

    # 4) sample
    Lval = float(numeric_values[L])
    xs   = np.linspace(0, Lval, 200)
    vs   = v_fun(xs)
    Ms   = M_fun(xs)

        # ——— broadcast if constant ———
    if np.isscalar(Ms) or Ms.ndim == 0:
        Ms = np.full_like(xs, Ms)

    if np.isscalar(vs) or vs.ndim == 0:
        vs = np.full_like(xs, vs)

    print("Test 5")
    # # 5) zero-out tiny noise
    # vs = np.where(np.abs(vs) < tol, 0.0, vs)
    # Ms = np.where(np.abs(Ms) < tol, 0.0, Ms)

    print("Test 6")
    # 6) plot side by side
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 4))

    ax1.plot(xs, vs, color='brown', linewidth=3)
    ax1.set_xlabel(r'$x\,(m)$')
    ax1.set_ylabel(r'$v(x)\,(m)$')
    ax1.set_title('Deslocamento $v(x)$')
    ax1.invert_yaxis()
    ax1.grid(True)

    ax2.plot(xs, Ms, color='green', linewidth=3)
    ax2.set_xlabel(r'$x\,(m)$')
    ax2.set_ylabel(r'$M(x)\,(N\cdot m)$')
    ax2.set_title('Momento Fletor $M(x)$')
    ax2.invert_yaxis()
    ax2.grid(True)

    # If Ms is now all zero, force a flat zero line
    if np.allclose(Ms, 0.0):
        ax2.set_ylim(0, 0)

    plt.savefig('my_figure.pdf', format='pdf', bbox_inches='tight')

    plt.tight_layout()
    plt.show()

    # 2) Download it to your laptop:
    from google.colab import files
    files.download('my_figure.pdf')

# Choose approximation order (e.g., 5)
order = 5
alphas, delta_alphas, v_poly, w_poly = ApproximationFunctions(order)


print("v(x)")
print(sp.latex(v_poly))
print("delta v(x)")
print(sp.latex(w_poly))


v_poly_bc = apply_boundary_conditions(v_poly, alphas, L)

# print(sol_BC)
# # Substitute BCs into v(x)
# v_poly_bc = sp.expand(v_poly.subs(sol_BC))
print("v(x) with BC's:")
display(sp.latex(v_poly_bc))

# Substitute BC-enforced v into energy expressions:
W_int_sub = W_int.subs({v: v_poly_bc, w: v_poly_bc})
W_ext_sub = W_ext.subs({v: v_poly_bc, w: v_poly_bc})

# Form virtual work equation:
PVW_substituted = sp.Eq(W_int_sub, W_ext_sub)

# Display results:
print("W_int (after substitution) =")
display(W_int_sub)

print("\nW_ext (after substitution) =")
display(W_ext_sub)

print("\nPVW (after substitution):")
display(PVW_substituted)
print(sp.latex(PVW_substituted))

# === (2)  Extract the “basis” functions φ₂,…,φ₅  ===

phi_basis = extract_basis_functions(v_poly_bc, alphas)

"""(2) $ \dfrac{d²}{dx²} \phi_i(x)$"""

d2_phi_dx2 = ComputeSecondDerivatives(phi_basis)

"""(3)  $ K_{ij} = \int_0^L E·I · \phi_i''(x)  \phi_j''(x) dx $

"""

alpha_vec = AssembleAndSolve(phi_basis,d2_phi_dx2)

# 6) Reconstruct v(x) = Σ α_i φ_i(x)
# v_solution = sum(alpha_vec[i] * phi_basis[i] for i in range(n))
# print("Reconstructed v(x):")
# print(sp.latex(v_solution))
v_solution = ReconstructSolution(alpha_vec,phi_basis)
display(v_solution)

numeric_values = {L: 1.0, E: 210e9, I: 1e-6, q: 1000.0, k:0e100}
PlotSolution(v_solution,numeric_values)

# QUESTAO 2


import sympy as sp
import numpy as np
import matplotlib.pyplot as plt
import numpy as np
import matplotlib as mpl

# Define symbols
x   =   sp.Symbol('x')
E   =   sp.Symbol('E')  # Young's Modulus
I   =   sp.Symbol('I')  # Area Moment of Inertia
v   =   sp.Function('v')(x)  # Virtual displacement field
w   =   sp.Function('\delta v')(x)  # Actual displacement field
q   =   sp.Symbol('q')  # Distributed load
P0  =   sp.Symbol('P_0')  # Concentraded load
PL  =   sp.Symbol('P_L')  # Concentraded load
M0  =   sp.Symbol('M_0')  # Concentraded moment
ML  =   sp.Symbol('M_L')  # Concentraded moment
L = sp.Symbol('L')
k = sp.Symbol('k')

# Define the principle of virtual work in integral form
# The integral represents the virtual work done by internal and external forces.
# Integral( E * I * w'' * v'' ) dx - Integral( q * v ) dx = 0
dvdx    = sp.Derivative(v, x)
dv2dx2  = sp.Derivative(dvdx, x)
dwdx    = sp.Derivative(w, x)
dw2dx2  = sp.Derivative(dwdx, x)


# Internal virtual work integral (due to bending moment)
W_int = sp.Integral(-E*I*dv2dx2*dw2dx2, (x, 0, L))

# External virtual work integral
# (due to distributed and concentraded forces and concentraded moments)
W_ext_q = sp.Integral(q * w, (x, 0, L))
W_ext_P = P0*w.subs(x,0) + PL*w.subs(x,L)
W_ext_M = M0*dwdx.subs(x,0) + ML*dwdx.subs(x,L)
W_ext_k = -k*v.subs(x,0)*w.subs(x,0) - k*v.subs(x,L)*w.subs(x,L)
W_ext = W_ext_q + W_ext_P + W_ext_M + W_ext_k


# The principle of virtual work statement:
# internal_virtual_work - external_virtual_work = 0
PVW = sp.Eq(W_ext, W_int)

# print("Internal Virtual Work Integral:")
print(sp.latex(W_int))

# print("\nExternal Virtual Work Integral:")
print(sp.latex(W_ext))

# print("\nPrinciple of Virtual Work Statement (Integral Form):")
display(PVW)

def apply_boundary_conditions(v_poly, alphas, L, n_elim=2):
    """
    Enforce boundary conditions:
        v(0) = 0
        v(L) = 0
        v''(0) = 0
        v''(L) = 0
    and solve for the first `n_elim` alpha_i coefficients.

    Parameters:
        v_poly: symbolic polynomial expression for v(x)
        alphas: list of alpha symbols
        L: symbolic length variable
        n_elim: how many alpha_i to eliminate (default: 4)

    Returns:
        v_poly_bc: BC-enforced polynomial
        sol_BC: dictionary of substitutions applied
    """
    # Compute first (for teta=0) and second derivative (for M=0)
    vp = sp.diff(v_poly, x)
    vpp = sp.diff(v_poly, x, 2)


    print("v(x)")
    print(sp.latex(v_poly))
    print("v(0)=")
    print(sp.latex(sp.Eq(v_poly.subs(x, 0), 0)))

    print("v' =")
    print(sp.latex(vp))
    print("v'(0)=")
    print(sp.latex(sp.Eq(vp.subs(x, 0), 0)))

    print("v''=")
    print(sp.latex(vpp))
    print("v''(L)=")
    print(sp.latex(sp.Eq(vpp.subs(x, L), 0)))

    # Apply boundary conditions
    bc_eqs = [
        sp.Eq(v_poly.subs(x, 0), 0),
        sp.Eq(vp.subs(x, 0), 0)
    ]
    print(bc_eqs)

    # Determine which coefficients to eliminate
    unknowns_to_solve = alphas[:n_elim]

    # Solve
    sol_BC = sp.solve(bc_eqs, unknowns_to_solve, dict=True)[0]

    # Substitute into v_poly
    v_poly_bc = sp.expand(v_poly.subs(sol_BC))
    # v_poly_bc = sp.expand(v_poly.subs(sol_BC))

    return v_poly_bc

# Choose approximation order (e.g., 5)
order = 3
alphas, delta_alphas, v_poly, w_poly = ApproximationFunctions(order)


print("v(x)")
print(sp.latex(v_poly))
print("delta v(x)")
print(sp.latex(w_poly))


v_poly_bc = apply_boundary_conditions(v_poly, alphas, L)

# print(sol_BC)
# # Substitute BCs into v(x)
# v_poly_bc = sp.expand(v_poly.subs(sol_BC))
print("v(x) with BC's:")
display(sp.latex(v_poly_bc))

# Substitute BC-enforced v into energy expressions:
W_int_sub = W_int.subs({v: v_poly_bc, w: v_poly_bc})
W_ext_sub = W_ext.subs({v: v_poly_bc, w: v_poly_bc})

# Form virtual work equation:
PVW_substituted = sp.Eq(W_int_sub, W_ext_sub)

# Display results:
print("W_int (after substitution) =")
display(W_int_sub)

print("\nW_ext (after substitution) =")
display(W_ext_sub)

print("\nPVW (after substitution):")
display(PVW_substituted)
print(sp.latex(PVW_substituted))




phi_basis = extract_basis_functions(v_poly_bc, alphas)
d2_phi_dx2 = ComputeSecondDerivatives(phi_basis)
alpha_vec = AssembleAndSolve(phi_basis,d2_phi_dx2)

v_solution = ReconstructSolution(alpha_vec,phi_basis)
display(v_solution)

numeric_values = {L: 1.0, E: 210e9, I: 1e-6, q: 1000.0, k:5e70}
PlotSolution(v_solution,numeric_values)


import sympy as sp
import numpy as np
import matplotlib.pyplot as plt
import numpy as np
import matplotlib as mpl

# Define symbols
x   =   sp.Symbol('x')
E   =   sp.Symbol('E')  # Young's Modulus
I   =   sp.Symbol('I')  # Area Moment of Inertia
v   =   sp.Function('v')(x)  # Virtual displacement field
w   =   sp.Function('\delta v')(x)  # Actual displacement field
q   =   sp.Symbol('q')  # Distributed load
P0  =   sp.Symbol('P_0')  # Concentraded load
PL  =   sp.Symbol('P_L')  # Concentraded load
M0  =   sp.Symbol('M_0')  # Concentraded moment
ML  =   sp.Symbol('M_L')  # Concentraded moment
L = sp.Symbol('L')
kd = sp.Symbol('k_d')

# Define the principle of virtual work in integral form
# The integral represents the virtual work done by internal and external forces.
# Integral( E * I * w'' * v'' ) dx - Integral( q * v ) dx = 0
dvdx    = sp.Derivative(v, x)
dv2dx2  = sp.Derivative(dvdx, x)
dwdx    = sp.Derivative(w, x)
dw2dx2  = sp.Derivative(dwdx, x)


# Internal virtual work integral (due to bending moment)
W_int = sp.Integral(-E*I*dv2dx2*dw2dx2, (x, 0, L))

# External virtual work integral
# (due to distributed and concentraded forces and concentraded moments)
W_ext_q = sp.Integral(q * w, (x, 0, L))
W_ext_P = P0*w.subs(x,0) + PL*w.subs(x,L)
W_ext_M = M0*dwdx.subs(x,0) + ML*dwdx.subs(x,L)
W_ext_k = sp.Integral(-kd*v*w, (x, 0, L))
W_ext = W_ext_q + W_ext_P + W_ext_M + W_ext_k


# The principle of virtual work statement:
# internal_virtual_work - external_virtual_work = 0
PVW = sp.Eq(W_ext, W_int)

# print("Internal Virtual Work Integral:")
print(sp.latex(W_int))

# print("\nExternal Virtual Work Integral:")
print(sp.latex(W_ext))

# print("\nPrinciple of Virtual Work Statement (Integral Form):")
display(PVW)

def apply_boundary_conditions(v_poly, alphas, L, n_elim=2):
    """
    Enforce boundary conditions:
        v(0) = 0
        v(L) = 0
        v''(0) = 0
        v''(L) = 0
    and solve for the first `n_elim` alpha_i coefficients.

    Parameters:
        v_poly: symbolic polynomial expression for v(x)
        alphas: list of alpha symbols
        L: symbolic length variable
        n_elim: how many alpha_i to eliminate (default: 4)

    Returns:
        v_poly_bc: BC-enforced polynomial
        sol_BC: dictionary of substitutions applied
    """
    # Compute first (for teta=0) and second derivative (for M=0)
    vp = sp.diff(v_poly, x)
    vpp = sp.diff(v_poly, x, 2)


    print("v(x)")
    print(sp.latex(v_poly))
    print("v(0)=")
    print(sp.latex(sp.Eq(v_poly.subs(x, 0), 0)))

    print("v' =")
    print(sp.latex(vp))
    print("v'(0)=")
    print(sp.latex(sp.Eq(vp.subs(x, 0), 0)))

    print("v''=")
    print(sp.latex(vpp))

    print("v''(0)=")
    print(sp.latex(sp.Eq(vpp.subs(x, 0), 0)))
    print("v''(L)=")
    print(sp.latex(sp.Eq(vpp.subs(x, L), 0)))

    # Apply boundary conditions
    bc_eqs = [
        sp.Eq(v_poly.subs(x, 0), 0),
        sp.Eq(v_poly.subs(x, L), 0)
    ]
    print(bc_eqs)

    # Determine which coefficients to eliminate
    unknowns_to_solve = alphas[:n_elim]

    # Solve
    sol_BC = sp.solve(bc_eqs, unknowns_to_solve, dict=True)[0]

    # Substitute into v_poly
    v_poly_bc = sp.expand(v_poly.subs(sol_BC))
    # v_poly_bc = sp.expand(v_poly.subs(sol_BC))

    return v_poly_bc

def AssembleAndSolve(phi_basis, d2_phi_dx2):
    # (D) Assemble the 4×4 stiffness matrix K in a nested loop
    n = len(d2_phi_dx2)  # = 4
    K = sp.zeros(n, n)

    for i in range(n):
        for j in range(n):
            K[i, j] =  sp.integrate(E*I * d2_phi_dx2[j] * d2_phi_dx2[i], (x, 0, L))
            K[i, j] += sp.integrate(kd * phi_basis[j] * phi_basis[i], (x, 0, L))
            if i == j and K[i,j] == 0:
                K[i,j] = 1

    display(K)
    # (E) Display the result
    print("Stiffness matrix K_{ij}:")
    print(sp.latex(K))

    F = sp.zeros(n, 1)
    for i in range(n):
        F[i,0] = sp.simplify( sp.integrate(q * phi_basis[i], (x,0,L)) )

    display(F)
    print("Force vector")
    print(sp.latex(F))

    alpha_vec = sp.simplify(K.LUsolve(F))

    print("Solution")
    print(sp.latex(alpha_vec))
    return alpha_vec

# Choose approximation order (e.g., 5)
order = 4
alphas, delta_alphas, v_poly, w_poly = ApproximationFunctions(order)


print("v(x)")
print(sp.latex(v_poly))
print("delta v(x)")
print(sp.latex(w_poly))


v_poly_bc = apply_boundary_conditions(v_poly, alphas, L)

# print(sol_BC)
# # Substitute BCs into v(x)
# v_poly_bc = sp.expand(v_poly.subs(sol_BC))
print("v(x) with BC's:")
display(sp.latex(v_poly_bc))

# Substitute BC-enforced v into energy expressions:
W_int_sub = W_int.subs({v: v_poly_bc, w: v_poly_bc})
W_ext_sub = W_ext.subs({v: v_poly_bc, w: v_poly_bc})

# Form virtual work equation:
PVW_substituted = sp.Eq(W_int_sub, W_ext_sub)

# Display results:
print("W_int (after substitution) =")
display(W_int_sub)

print("\nW_ext (after substitution) =")
display(W_ext_sub)

print("\nPVW (after substitution):")
display(PVW_substituted)
print(sp.latex(PVW_substituted))




phi_basis = extract_basis_functions(v_poly_bc, alphas)
d2_phi_dx2 = ComputeSecondDerivatives(phi_basis)
alpha_vec = AssembleAndSolve(phi_basis,d2_phi_dx2)

v_solution = ReconstructSolution(alpha_vec,phi_basis)
print("SOlution:")
display(v_solution)
print("SOlution with k_d = 0")
display(sp.simplify(v_solution.subs(kd,0)))
print(sp.latex(sp.simplify(v_solution.subs(kd,0))))

numeric_values = {L: 1.0, E: 210e9, I: 1e-6, q: 1000.0, kd:5e-70}
PlotSolution(v_solution,numeric_values)